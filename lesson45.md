# Урок 45. Linux. Базовые команды. sudo. apt. Переменные окружения.

[/не отображается/]: # (![]&#40;http://memesmix.net/media/created/8ewe0t.jpg&#41;)

## Что такое операционная система?

Операционная система является основным программным обеспечением, которое управляет всем аппаратным и другим программным
обеспечением на компьютере. Операционная система, также известная как **ОС**, взаимодействует с аппаратным обеспечением
компьютера и предоставляет службы, которые могут использовать приложения.

![](https://media.discordapp.net/attachments/943973009788641300/1190088341186686976/b573ad7c999d7443.jpg?ex=65a9c1a3&is=65974ca3&hm=636f2c77d679a1ec82586745dcf0ef683a91604196cd41c7b8365919ee943a3d&=&format=webp&width=745&height=621)

### Что делает операционная система?

Операционная система является основным набором программного обеспечения на устройстве, которое поддерживает все вместе.
Операционные системы взаимодействуют с оборудованием устройства. Они обрабатывают всё: от клавиатуры и мыши до
Wi-Fi-радио, устройств хранения и отображения. Другими словами, операционная система обрабатывает устройства ввода и
вывода. Операционные системы используют драйверы устройств, написанные разработчиками оборудования для связи со своими
устройствами.

Операционные системы также включают в себя множество программных продуктов, таких как общие системные службы, библиотеки
и интерфейсы прикладного программирования (API), которые разработчики могут использовать для написания программ,
работающих в операционной системе.

Операционная система находится между приложениями, которые Вы запускаете, и оборудованием, используя аппаратные драйверы
в качестве интерфейса между ними. Например, когда приложение хочет что-то напечатать, оно переносит эту задачу в
операционную систему. Операционная система отправляет инструкции на принтер, используя драйверы принтера для отправки
правильных сигналов. Приложению, которое печатает, не нужно заботиться о том, какой принтер у Вас есть, или понять, как
он работает. ОС обрабатывает детали.

ОС также обрабатывает многозадачность, выделяя аппаратные ресурсы среди нескольких запущенных программ. Операционная
система контролирует, какие процессы выполняются, и распределяет их между различными ЦП, если у Вас есть компьютер с
несколькими процессорами или ядрами, позволяя нескольким процессам работать параллельно. Она также управляет внутренней
памятью системы, выделяя память между запущенными приложениями.

**Операционная система** — это одна большая часть программного обеспечения, которая отвечает за многое. Например,
операционная система также контролирует файлы и другие ресурсы, к которым могут обращаться программы.

Большинство программных приложений написано для операционных систем, что позволяет операционной системе делать много
работы. Например, при запуске Minecraft Вы запускаете его в операционной системе. Minecraft не должен точно знать, как
работает каждый отдельный аппаратный компонент. Minecraft использует различные функции операционной системы, а
операционная система переводит их в низкоуровневые аппаратные инструкции.

![](http://img2.joyreactor.cc/pics/post/%D0%B1%D0%B5%D0%B7-%D0%BF%D0%B5%D1%80%D0%B5%D0%B2%D0%BE%D0%B4%D0%B0-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B-windows-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0-6015797.jpeg)

### Операционные системы предназначены не только для ПК

Когда мы говорим, что «компьютеры» запускают операционные системы, мы не просто имеем в виду традиционные настольные ПК
и ноутбуки. Ваш смартфон — это компьютер, как и планшеты, смарт-телевизоры, игровые консоли, смарт-часы и маршрутизаторы
Wi-Fi. Amazon Echo или Google Home — это компьютерное устройство, работающее под управлением операционной системы.

Знакомые настольные операционные системы включают Microsoft Windows, Apple MacOS, Google Chrome OS и Linux. Основными
операционными системами для смартфонов являются iOS от Apple и Android от Google.

Другие устройства, такие как маршрутизатор Wi-Fi, могут запускать «встроенные операционные системы». Это
специализированные операционные системы с меньшим количеством функций, чем имеет обычная операционная система,
разработанная специально для одной задачи — например, для работы с маршрутизатором Wi-Fi, навигации или управления
банкоматом.

![](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRoyMlj1Z11nKk6xruy4Ob9a0myfhV56wn3FA&usqp=CAU)

### Где заканчиваются операционные системы и начинаются программы?

Операционные системы также включают другое программное обеспечение, включая пользовательский интерфейс, который
позволяет людям взаимодействовать с устройством. Это может быть рабочий стол на ПК, сенсорный интерфейс на телефоне или
голосовой интерфейс на цифровом помощнике.

**Операционная система** — это большое программное обеспечение, состоящее из множества различных приложений и процессов.
Линия между тем, что является операционной системой и что такое программа, может иногда быть немного размытой. Точного
официального определения операционной системы нет.

Например, в Windows приложение File Explorer (или Windows Explorer) является неотъемлемой частью операционной системы
Windows — оно даже обрабатывает отрисовку Вашего рабочего интерфейса — и приложением, работающим в этой операционной
системе.

![](https://memegenerator.net/img/instances/23745895.jpg)

### Центром операционной системы является ядро

На низком уровне «ядро» является основной компьютерной программой, лежащей в основе Вашей операционной системы. Эта
отдельная программа является одной из первых вещей, загружаемых при запуске Вашей операционной системы. Оно обрабатывает
выделение памяти, преобразование программных функций в инструкции для процессора Вашего компьютера и обработку входных и
выходных данных с аппаратных устройств. Ядро, как правило, запускается в изолированной области, чтобы предотвратить его
несанкционированное использование другим программным обеспечением на компьютере. Ядро операционной системы очень важно,
но это всего лишь одна часть операционной системы.

Но и здесь не все конкретно. Например, Linux — это просто ядро. Однако Linux по-прежнему часто называют операционной
системой. Android также называется операционной системой, и она построена на ядре Linux. Такие Linux-дистрибутивы, как
Ubuntu, используют ядро Linux и добавляют к нему дополнительное программное обеспечение. Они также называются
операционными системами.

## Сравнение с Windows

Довольно подробная статья на эту
тему [тут](https://ravesli.com/sravnenie-linux-i-windows-v-chem-raznitsa-i-chto-luchshe/)

### Доля рынка

ОС Windows обычно называют лучшей ОС для начинающих пользователей. По данным NetMarketShare за 2020 год мировая доля ОС
Windows на настольных компьютерах составляет 87%, в то время как macOS занимает 9% рынка, а Linux — всего лишь 2%.

### Совместимость

Несмотря на недавние улучшения в программном обеспечении, переносимого с других платформ или разрабатываемом на Linux,
Windows по-прежнему является «королем совместимости».

Пользователи Windows могут быть уверены, что практически любое ПО (даже самое малоизвестное и устаревшее) будет
работать, даже если его перестали развивать сами разработчики. Windows имеет отличную поддержку устаревшего ПО.

### Цена

![](https://ravesli.com/wp-content/uploads/2021/01/update_OS.jpg)

Ядро Linux (и сопутствующие с ним утилиты и библиотеки GNU) в большинстве дистрибутивов (Debian, Fedora, Ubuntu, Manjaro
и пр.) полностью свободны (часто — бесплатны) и имеют открытый исходный код благодаря соответствующей лицензии GNU GPL и
её вариациям. Компании (например, Red Hat, SUSE) предлагают платную поддержку своих дистрибутивов (Red Hat Enterprise
Linux, SUSE Linux Enterprise Server), но базовое программное обеспечение по-прежнему можно скачать и установить
бесплатно.

### Игры

Если вы геймер и вам нужна 100% совместимость с определенным программным обеспечением, то тут без компромиссов побеждает
Windows. Сервис Steam, помимо прочих клиентов и лончеров, предоставляет огромное количество игр как от ААА-издателей,
так и от небольших инди-разработчиков.

Steam для Linux теперь позволяет устанавливать игры для Windows, но он все еще находится в процессе развития, и не все
игры для Windows будут на нем корректно работать (если вообще запустятся). Кроме того, вы также можете поиграть в
некоторые специфичные для Windows игры на Linux через Wine или Proton.

### Программирование

Linux поддерживает почти все основные языки программирования (Python, C/C++, Java, Ruby, Perl и др.). Кроме того, он
предоставляет широкий спектр приложений, полезных для программирования и разработки различных приложений. Вы найдете
множество библиотек, изначально разработанных для Linux. Многие программисты отмечают, что они могут легко выполнять
рутинные задачи с помощью менеджера пакетов в Linux. Возможность писать сценарии в различных оболочках также является
одной из самых убедительных причин, почему программисты предпочитают использовать Linux. Он также предоставляет
встроенную поддержку протокола SSH, с помощью которого вы с легкостью сможете быстро управлять своими серверами.

В Windows же есть своя платформа .NET Framework, которая позволяет писать программные продукты. Главной особенностью
данной платформы является то, что это продукт Microsoft (который создавался в качестве альтернативы платформе Java от
компании Sun) и официально работает он только с семейством операционных систем Windows. Со времен выпуска .NET Framework
в 2002 году появилось множество программных продуктов, библиотек и фреймворков, созданных с помощью данной платформы для
работы исключительно под Windows. Основным языком программирования в .NET Framework является язык C# —
объектно-ориентированный язык программирования, созданный специалистами компании Microsoft как язык разработки
приложений для платформы Microsoft .NET Framework. Если Linux у разработчиков ассоциируется с поддержкой и работой с
множеством различных языков программирования, то «визитной карточкой» Windows является .NET Framework и язык C#.

### Серверы

Если вы думаете о безопасности сервера, стабильности, свободе выбора, совместимости оборудования и экономической
эффективности, то сервер на Linux превосходит аналогичный сервер на Windows во всех отношениях. Windows — это популярный
вариант для настольного использования, а Linux — лучший вариант для серверных систем.

Серверный дистрибутив Linux предлагает множество различных вариантов настройки системы с широким спектром эффективных
инструментов мониторинга и анализа её работоспособности. Linux, в отличие от Windows, менее уязвим к различным
кибератакам и проникновению на сервер вредоносных программ. В ядре Linux практически невозможно создать какой-либо
бэкдор, в то время как система Windows очень чувствительна к такому сценарию развития событий.

## Дистрибутивы

![](https://habrastorage.org/getpro/habr/upload_files/e88/162/238/e88162238bc8fe07f5429772c919e4e4.png)

Во-первых, нам нужно рассмотреть один из наиболее запутанных аспектов платформы Linux. В то время как Windows сохранила
вполне стандартную структуру версий, с минорными и мажорными обновлениями, в Linux же всё обстоит гораздо сложнее.

На сегодняшний день ядро Linux лежит в основе всех операционных систем на базе Linux. Однако, поскольку его исходные
коды остаются открытыми, любой человек может настроить или изменить ОС для своих собственных целей. В результате мы
имеем сотни индивидуальных Linux-подобных операционных систем, называемых дистрибутивами. Это делает невероятно трудным
выбор между ними, гораздо более сложным, чем просто выбор между Windows 7, Windows 8 или Windows 10.

Но у такого расклада есть и свои достоинства. Учитывая природу программного обеспечения с открытым исходным кодом, эти
дистрибутивы могут сильно отличаться по функциональности и сложности, ведь каждый дистрибутив Linux имеет свой цикл
разработки, и многие из них постоянно развиваются.

В случае с Windows существует только одна компания — Microsoft, которая занимается разработкой и обслуживанием всей
операционной системы: ядро, среда рабочего стола и большая часть предустановленного программного обеспечения. Вы должны
принимать всё, что они вам предлагают, независимо от того, будет это вам полезно или нет.

Все примеры ниже будут базироваться на Ubuntu/Mint дистрибутивах.

## Командная строка

![](https://memegenerator.net/img/instances/52898768.jpg)

### Общая концепция того, что всё это файл

Давайте сначала разберемся как вообще это может работать. В Linux есть такое понятие как корневая файловая система. В
качестве неё монтируется раздел жесткого диска, на котором установлен Linux. В различные подпапки подключаются другие
реальные разделы жесткого диска, например, домашний раздел подключается в папку `/home`, а загрузочный в папку `/boot`. 
Но существуют не только реальные файловые системы, но и виртуальные файловые системы, созданные ядром, например, в папку
`/proc` монтируется файловая система `procfs`, которая позволяет получить доступ к параметрам ядра, а в папку `/dev`
монтируется `devfs` содержащий устройства, подключённые к компьютеру, и тоже в виде файлов.

Так вот, вообще всё это файл.

![](https://pbs.twimg.com/media/EVfgImLUcAAbBbj.jpg)

- Подключаемые устройства (принтеры, флешки и т. д.) для Linux - это файл, и в них при желании можно писать или читать
  данные.
- Информация о ядре - это тоже файл.
- Конфигурация ядра - это, не поверите, тоже файл.
- Сокеты - странные, но файлы.

#### Что такое Linux сокеты?

**Сокеты** - это специальные файлы для взаимодействия между процессами по сети. Создаётся специальный файл, в который,
допустим, один процесс пишет данные, а еще два считывают. Такой механизм нужен, чтобы явно было понятно, через какой
объект данные общаются, и мы будем пользоваться такими файлами в дальнейшем.

### Зачем нам нужен терминал (консоль)?

С исторической точки зрения, когда создавалось ядро Linux, понятия UI (User Interface - то, что вы привыкли видеть на
всех ваших устройствах, открытые папки, запущенные приложения открытый браузер и т. д.) просто не существовало. Все
возможности ядра использовались только через консоль.

[/не отображается/]: # (![]&#40;https://linuxrussia.com/static/7ff6347fa375265c8a49ae65fd3017de/6ea47/terminal_linux_1.png&#41;)

А это значит, что все выполняемые команды или параметры передавались исключительно как белый текст на чёрном фоне.
Никаких красивых кнопок или понятных картиночек)

У очень большого количества программ для Linux всё еще нет никакого UI, только белые буквы на чёрном фоне. Существуют
дистрибутивы (активно используются, и мы будем использовать такой через занятие)^ где всё еще существует только консоль.
Запустили устройство, а всё^ что у вас есть, — это чёрный фон и белые буквы. :)

Как это работает?

- Ядро читает команду, набранную на клавиатуре из терминала.
- Команда валидируется.
- Команда запускается.
- Результат выводится на экран (ну, или допустим, пишется в файл и т. д.).
- Идём к пункту 1.

#### Аргументы и параметры

**Команда** — это последовательность символов, которая заканчивается нажатием клавиши `Enter` и впоследствии
обрабатывается оболочкой.

Чтобы интерпретировать командную строку, оболочка сначала пытается разделить строку на слова. Как и в реальной жизни
слова разделяются пробелами. Первое слово в строке обычно является фактической командой. Все остальные слова в строке
являются параметрами, более подробно объясняющими, что требуется.

Параметры, начинающиеся с дефиса (``-``), называются **опциями**. Если вы хотите передать команде несколько опций, их
можно (часто) сгруппировать за одним дефисом, т. е. последовательность опций ``-a -l -F`` - это то же самое, что и 
``-alF``. Многие программы имеют больше опций, чем можно удобно сопоставить с одним символом, ну или просто требуется 
более читаемое написание. Для этого используются "длинные параметры", они начинаются с двух дефисов и не собираются в 
одно длинное слово: ``foo --bar --baz``.

Параметры без дефиса в начале называются **аргументами**. Часто это имена файлов (например, `python manage.py`), которые
должна обработать команда.

Таким образом, общая *структура команд* может отображаться следующим образом:

: команда: 
<что делать?>
:параметры:
<как это сделать?>
:аргументы:
<с чем это делать?>

### Навигация

![](https://www.memecreator.org/static/images/memes/4827651.jpg)

**В линуксе нет `дисков` как `C:/`, `D:/` итд. Есть только корневая директория `/`, с которой всё и начинается.

Чаще всего есть папка `/home`, внутри которой будут еще папки с вашими пользователями. Если у вас один пользователь, то 
и папка будет одна, обычно это единственное место, где можно выполнять все действия без пароля. Как работают 
разграничения пользователей дальше в лекции.

Значок `~` (тильда) означает домашний каталог текущего пользователя.

Путь может быть абсолютным или относительным. **Полный, или абсолютный путь** — это путь, который указывает на одно и 
то же место в файловой системе вне зависимости от текущего рабочего каталога или других обстоятельств. Полный путь 
всегда начинается с корневого каталога. **Относительный путь** представляет собой путь по отношению к текущему рабочему
каталогу пользователя или активных приложений.

Команда `pwd` (*print working directory*) отображает абсолютный путь в текущую директорию.

Если при начале набора любого названия файла или папки нажать клавишу `TAB`, система подскажет вам первый файл,
начинающийся с этих символов (без символов просто подставит первый файл в папке), при повторном нажатии появится
следующий соответствующий файл, если он есть.

#### cd

Команда `cd` (*change directory*) позволяет изменить текущую папку. Мы можем указать ей как абсолютный 
`cd /home/my_user`, так и относительный `cd my_images`(находясь, допустим, в папке `/home/my_user`) пути.

Перейти на директорию уровнем выше `cd ..` (были в `/home/my_user/my_images/`, попали в `/home/my_user/`)

Перейти на директорию двумя уровнями выше `cd ../..` (были в `/home/my_user/my_images/`, попали в `/home`)

Перейти в вашу домашнюю директорию откуда угодно `cd ~`.

Перейти в директорию, в которой вы находились до перехода, - `cd -`.

#### ls

`ls` (*list*) показывает список файлов и папок в текущей директории.

С флагом `-l` покажет детали каждого файла.

С флагом `-a` покажет скрытые файлы и папки.

Часто используется с комбинированным ключом `ls -la`.

Последняя команда в Ubuntu/Mint и не только дистрибутивах изначально может быть заменена на алиас `ll` (не работает на
Mac).

### Создание, удаление, перемещение, переименование, копирование файлов и папок

Создать файл в командной строке Linux можно тремя способами.

1) Команда `touch`

`touch /путь/к/файлу/название_файла`

или

`touch file.txt` - создаст пустой файл

[/не отображается/]: # (![]&#40;https://linuxrussia.com/static/f36633e5027ed395ef71a6b652e19821/7fca0/terminal_linux_1.png&#41;)

Мы всё еще можем указать абсолютный или относительный путь

2) Перенаправить вывод практически любой команды в файл. Это делается при помощи символа (`>`). Если помните, как снять
   `requirements.txt`, то точно понимаете, о чём я.

В общем виде команда выглядит так:

`какая_нибудь_команда > /путь/к/файлу/наименование_файла`

Как пример:

`ls --help > ls_help.txt`

Создаст файл `ls_help.txt` в текущей папке, который будет содержать результат команды `ls --help` с деталями по
использованию команды `ls`.

Если использовать символ `>` два раза, то данные, если файл уже будет существовать, допишутся в конец, а не перепишут 
весь файл.

3) Используя текстовый редактор.

В Linux существует несколько различных текстовых редакторов, существуют даже со сложными графическими интерфейсами, но
мы чаще всего будем использовать либо `nano`, либо `vim`. Я лично предпочитаю использовать `nano` т. к. это самый 
простой и удобный (для меня) редактор, но многие предпочитают `vim`, так как его можно настроить настолько гибко, что 
он даже особо не будет отличаться от PyCharm. Но, выбирая `vim`, всегда помните, что вопрос *Как выйти из vim?* является
самым популярным вопросом из Украины на
StackOverflow [вопрос](https://stackoverflow.com/questions/11828270/how-do-i-exit-the-vim-editor). У этого вопроса 2.9
миллиона просмотров :)

`nano nano_file.txt`

И для закрытия редактора используйте команды самого редактора (у `nano` - это `Ctrl+X`)

#### Создание папки (каталога, директории)

Чтобы создать папку, нужно использовать команду `mkdir` (*make directory*), также можно использовать абсолютный и
относительный путь

`mkdir dir_name`

Создать сразу две папки:

`mkdir dir1 dir2`

Создать дерево:

`mkdir -p /dir1/dir2`

#### Удаление папки или файла

Для удаления папки используется команда `rmdir` (*remove directory*):

`rmdir dir_name`

Для удаления файла используется `rm` (*remove*):

`rm some_file`

Эту команду можно использовать и для удаления папки, если добавить флаг `-r`, обозначающий рекурсивно (вместе со всем
содержимым):

`rm -r dir1`

Или сразу несколько папок:

`rm -r dir1 dir2`

Также есть флаг `-f`, который обозначает (*force*) без уточнения, уверены ли вы, что хотите удалить, флаги всё еще можно
комбинировать.

`rm -rf dir1`

#### Переименовать или переместить файл

Переименование и перемещение файлов происходит одной и той же командой `mv`(*move*):

`mv название_файла новое_название`

или переместить файл:

`mv название_файла путь/`

#### Копировать файл или папку

Для этого используется команда `cp` (*copy*):

Скопировать файл `file1` и назвать копию `file2`:

`cp file1 file2`

Скопировать папку:

`cp -a dir1/ dir2/`

Скопировать файл в папку:

`cp file1 dir1/`

#### Справка

У всех базовых команд есть справка, и вызывается она через параметр `--help`, где вы можете посмотреть детали той или 
иной команды:

`rm --help`

`touch --help`

### Поиск по файлам

Для поиска используются две основные команды `find` и `locate`.

Все детали о том как они работают [тут](https://linuxrussia.com/terminal-search-files.html).

### Чтение файлов

Команда `more` (больше) нужна для чтения текстовых файлов:

`more some.txt`

Забудьте о её существовании)

Используйте команду `less`:

`less <путь_к_файлу/имя_файла>`

`less less.txt`

[/не отображается/]: # (![]&#40;https://linuxrussia.com/static/aa9bb35340fe739e601760a8587f605f/125bb/terminal_linux_4.png&#41;)

Есть куча параметров, таких как переход к определённой строке, поиск текста и т. д.

### Команды head и tail

Как можно понять из названий, показывают начало или конец файл соответственно.

`head [опции] <путь_к_файлу/имя_файла>`

`head error.log`

`tail [опции] <путь_к_файлу/имя_файла>`

`tail error.log`

`tail` самая часто используемая команда для чтения логов, т. к. обычно ошибки в самом конце.

Обладает параметром `-f`,он нужен, чтобы при обновлении файла показывать эти обновления в режиме реального времени 
(Допустим, если сервер работает, и ошибки нужно отображать прямо сейчас)

### Команды cat и tac

Нужны для просмотра целиком небольших текстовых файлов:

`cat [опции] <путь_к_файлу/имя_файла>`

`cat test1`

[/не отображается/]: # (![]&#40;https://linuxrussia.com/static/9c9fe482fcf66f836fc9f7830f004b4c/cf738/terminal_linux_17.png&#41;)

На самом деле, при комбинировании некоторых свойств можно делать не совсем очевидные вещи.

Например, добавить текст из одного файла в другой:

`cat test2 >> test3`

или объединить несколько файлов в один:

`cat test1 test2 > test4`

`tac` работает точно также, но выводит файл в обратном порядке (неизвестно, зачем нужен, в отличие от `cat` ни разу не
использовал)

## Пользователи, группы и права

![](https://hackernoon.com/hn-images/1*XlDjwO5LuWdhAnHk5Dhiww.png)

### sudo

У любого объекта в Linux существует набор прав, который обозначает, кому и что можно с этим файлом делать.

Также при установке системы всегда создаётся так называемый супер пользователь, для которого задаётся пароль.

Любую команду можно выполнить от имени суперпользователя, если вы знаете пароль, и эта команда проигнорирует все
возможные разрешения.

Для того чтобы выполнить такую команду, нужно использовать перед командой специальное слово `sudo`.

### Права

Чтобы проверить права файлов в текущей директории, необходимо выполнить команду `ls -l`:

[/не отображается/]: # (![]&#40;https://linuxrussia.com/static/b06169b8eaec43b22cf1f29dd0e3251b/dcacf/terminal_linux_1.png&#41;)

Вот эти страшные символы в начале и есть права доступа.

Если вы хотите посмотреть права для конкретного файла или папки, вы можете использовать:

`ls -l имя_нужного_файла`

`ls -l имя_нужной_директории`

### Как разобраться с тем, что написано в правах?

Допустим, у нас есть такие права `drwxrwxr-x`.

Это символьная форма записи прав, состоит из 10 символов.

Первый символ обозначает тип данных.

Может быть:

- `\` - обычный файл;
- `d` - директория;
- `l` - симлинк, разберём на следующем занятии.

Но бывают и более экзотические версии:

- `b` - файл блочного устройства;
- `c` - файл символьного устройства;
- `s` - доменное гнездо (socket);
- `p` - именованный канал (pipe).

Последние 4 крайне редки, но `socket` мы будем использовать.

Следующие 9 символов обозначают права доступа.

`rwxrwxr-x`

На самом деле, состоит из 3 групп по 3 символа:

`rwx rwx r-x`

- Первая группа из трех символов обозначает права доступа *владельца* файла или директории (*u - user*).
- Вторая группа из трех символов обозначает права доступа на файл или директорию для *системной группы* (*g - group*).
- Третья группа из трех символов обозначает права доступа на файл или директорию для *всех остальных* (*o - others*).

У этих трёх групп одинаковая комбинация символов, то есть:

`rwx`

Что они обозначают:

- `r` - это `read`, то есть право доступа на чтение файла или директории.
- `w` - это `write`, то есть право на изменение и удаление файла или директории.
- `x` - это `execute`, то есть право на запуск файла как программы или вход в директорию.

Всегда располагаются именно в таком порядке, и если одной (или больше) из этих букв нет, то этого права тоже нет.

Если взять наш пример:

`drwxrwxr-x`

это сообщение обозначает, что является директорией, у владельца и у группы есть полные права доступа - на чтение,
изменение, удаление, запуск (вход внутрь каталога), у всех остальных есть только права на чтение и запуск (вход внутрь
каталога).

### Как понять, кто владелец и какой группе принадлежит файл?

Если мы посмотрим внимательнее на скрин из команды `ls -l`, то увидим всю нужную информацию:

[/не отображается/]: # (![]&#40;https://linuxrussia.com/static/ff58a7f42c1e1f5d56658c556fe4a8e1/7fca0/terminal_linux_5.png&#41;)

Как видно на скриншоте:

- в третьей колонке идет имя владельца файла;
- в четвертой колонке идет название группы.

### Изменение прав

Для изменения прав в текстовом режиме (бывает еще числовой, рассмотрим ниже, и он используется чаще)

Нужно выполнить команду `chmod`Ж

`chmod personsOperatorRights имя_файла_или_имя_директории`

Вместо `persons` нужно использовать совокупность символов или один из:

- `u` (*user*) - пользователь, владелец файла или директории.
- `g` (*group*) - группа файла или директории.
- `o` (*others*) - все остальные.
- `a` (*all*), то есть все вместе взятые - владелец, группа и все остальные.

Этот символ обозначает субъект, которому будут назначены, удалены или изменены права.

Вместо `Operator` может быть один из следующих символов:

- `+` "плюс", добавляем нужные права.
- `-` "минус", удаляем нужные права.
- `=` "равно", устанавливаем нужные права.

Этот символ обозначает оператор, от которого зависит, будут ли добавлены, удалены или установлены нужные права, которые
последуют за оператором.

Вместо `Rights` перечисляем символы прав доступа:

- `r` (*read*) - чтение.
- `w` (*write*) - запись.
- `x` (*execute*) - выполнение.

Здесь идёт цепочка из трёх перечисленных символов, но в определённом порядке `rwx`. Но при этом не нужно указывать тире
для пропуска. Примеры: `rwx, rw, wx, rx, r, w, x`.

Если Вы не являетесь владельцем файла или директории или у вас нет прав на изменение файла, то нужно будет использовать
права суперпользователя:

`sudo chmod personsOperatorRights имя_файла_или_имя_директории`

### Примеры:

Убираем права для группы на изменение файла:

`chmod g-w file1`

Убираем права на чтение у группы и всех остальных:

`chmod go-r file1`

Добавим для группы права на чтение и изменение:

`chmod g+rw file1`

Изменим рекурсивно права на файлы и директории внутри нужной директории. Отменим, к примеру, все права у остальных
пользователей и групп:

`chmod -R o-rwx ~/my_images/`

`-R` в данном случае значит рекурсивно (все вложенные в папку объекты тоже изменятся)

Можно не указывать объект, если вы хотите заменить определённое право для всех, например, всем разрешить исполнять файл.

`chmod +x имя_файла.sh`

### Изменение прав (числовой способ)

Я лично чаще встречал изменения прав доступа в числовом виде, поэтому рекомендую в нём разобраться тоже.

Итак, допустим, у нас всё еще есть вот такие права, которые мы хотим назначить:

`rwxrwxr-x`

Чтобы преобразовать их в число, нужно разбить их на 3 группы:

`rwx rwx r-x`

Теперь, если символ есть заменить его на 1, если прочерк, то заменить его на 0:

`111 111 101`

А теперь перевести это число из двоичной системы в восьмеричную:

`7 7 5`

Вот мы и получили числовую запись прав доступа

Например:

`chmod 775 имя_файла`

Или

`chmod 700 имя_файла` - предоставить права на всё, но только владельцу файла.

### Замена владельца файла или группы

Для этого есть специальная команда `chown` (*change owner*).

Использовать так:

`sudo chown имя_нового_владельца:имя_новой_группы имя_файла_или_директории`

Необязательно указывать и владельца, и группу, можно изменить только что-то одно, и так же принимает параметр 
рекурсивно:

`sudo chown :имя_новой_группы имя_файла_или_директории`

`sudo chown имя_нового_владельца имя_файла_или_директории`

`sudo chown -R имя_нового_владельца:имя_новой_группы имя_директории`

### Текущий пользователь

Чтобы узнать текущего пользователя, используйте команду `whoami`.

Чтобы узнать группы текущих пользователей, используйте команду `groups`.

Чтобы получить список пользователей, используйте команду `users`.

Чтобы получить группы конкретного пользователя, используйте команду `groups user_name`.

Если нам необходимо, чтобы доступ к файлу имел только суперпользователь, можно указать в качестве владельца
файла `root`.

`sudo chown root file1`

Изменится сразу и владелец группы.

## APT или менеджер приложений

Естественно, как и в любой другой операционной системе, мы можем устанавливать различные приложения, допустим, тот же
`postgres` или даже `Python`.

Для управления установленными пакетами в семействе дистрибутивов Ubuntu/Mint мы можем использовать менеджер APT 
(Advanced Package Tool).

Для более ранних версий чем, например, Ubuntu 16.04, можно было бы использовать `apt-get`.

### Обновление списка доступных приложений

Для обновления списка доступных приложений используется команда `update`. Обратите внимание, что такая операция будет
требовать `sudo`.

`sudo apt update`

Вывод этой команды на экран включает данные о доступных пакетах, полученные от различных серверов.

![](https://blog.sedicomm.com/wp-content/uploads/2018/04/image_2020-12-14_215804.png)

Каждая строка вывода начинается с одного из трёх идентификаторов: `Hit`, `Ign` и `Get`, имеющих следующие трактовки 
значений:

- `Hit` — доступных обновлений для данного пакета сейчас нет.
- `Ign` — данный пакет игнорируется, так как его нельзя проверить или при проверке обновлений возник тривиальный сбой
   (не беспокойтесь, это не ошибка)
- `Get` — доступна для скачивания более новая версия пакета.

Обратите внимание, мы ничего не обновляли, а только проверили наличие обновлений в системе. Для скачивания всех
доступных обновлений используется следующая команда:

`sudo apt upgrade`

### Установка нового пакета

Для установки нового пакета используется команда:

`sudo apt install package_name`

При установке пакетов тоже будет работать `TAB`, например, если вы начнёте писать `net-t` и нажмете `TAB`, вам выпадет 
список из доступных приложений, там как минимум будет `net-tools` и `net-telnet-cisco`.

Можно установить несколько пакетов одновременно:

`sudo apt install package_1 package_2 package_3`

Если вы попытаетесь установить уже установленный пакет, система просто проверит наличие обновлений, и если
обнаружит, то установит их.

Можно установить конкретную версию пакета, для этого её необходимо указать явно:

`sudo apt install package_name=version_number`

### Удаление пакета

Для удаления пакета используется две разные команды:

`sudo apt remove package_name`

или

`sudo apt purge package_name`

- `remove` — удаляет все двоичные файлы пакета, но не трогает его файлы конфигурации;
- `purge` — удаляет и пакет, и его файлы конфигурации.

То есть, если вы удалите что-то через `remove` и потом переустановите, у вас будут сохранены прошлые настройки, а если
через `purge`, то абсолютно заново установленная программа.

У команды также есть возможность удалить не используемые приложения через команду `sudo apt autoremove`.

## Переменные окружения

Очень часто для различных программ или задач необходимо сохранить какую-либо переменную, причём сделать это прямо в
операционной системе. (Мы будем использовать их, например, для хранения паролей от базы или SECRET_KEY из Django)

Какие варианты нам предлагает Linux? Давайте посмотрим.

### Виды переменных

Если смотреть более широко, переменная окружения может быть трех типов.

#### Локальные переменные окружения

Эти переменные определены только для текущей сессии. Они будут безвозвратно стерты после завершения сессии, будь то
удаленный доступ или эмулятор терминала. Они не хранятся ни в каких файлах, а создаются и удаляются с помощью
специальных команд.

#### Пользовательские переменные окружения

Эти переменные оболочки в Linux определяются для конкретного пользователя и загружаются каждый раз, когда он входит в
систему при помощи локального терминала или же подключается удаленно. Такие переменные, как правило, хранятся в файлах
конфигурации: `.bashrc`, `.bash_profile`, `.bash_login`, `.profile` или в других файлах, размещенных в директории 
пользователя.

#### Системные переменные окружения

Эти переменные доступны во всей системе для всех пользователей. Они загружаются при старте системы из системных файлов
конфигурации:  `/etc/environment`, `/etc/profile`, `/etc/profile.d/`, `/etc/bash.bashrc`.

### Конфигурационные файлы переменных окружения в LINUX

#### .bashrc

Это файл переменных конкретного пользователя. Загружается каждый раз, когда пользователь создает терминальный сеанс, то
есть, проще говоря, открывает новый терминал. Все переменные окружения, созданные в этом файле, вступают в силу каждый 
раз, когда началась новая терминальная сессия.

#### .bash_profile

Эти переменные вступают в силу каждый раз, когда пользователь подключается удаленно по SSH (рассмотрим в следующей
лекции). Если этот файл отсутствует, система будет искать `.bash_login` или `.profile`.

#### /etc/environment 

Этот файл для создания, редактирования и удаления каких-либо переменных окружения на системном уровне.
Переменные окружения, созданные в этом файле, доступны для всей системы, для каждого пользователя и даже при удаленном
подключении.

#### /etc/bash.bashrc 

Системный `bashrc`. Этот файл выполняется для каждого пользователя каждый раз, когда он создает новую
терминальную сессию. Это работает только для локальных пользователей, при подключении через интернет такие переменные
не будут видны.

#### /etc/profile

Системный файл `profile`. Все переменные из этого файла, доступны любому пользователю в системе, только если
он вошел удаленно. Но они не будут доступны при создании локальной терминальной сессии, то есть, если вы просто откроете
терминал.

Все переменные окружения Linux, созданные с помощью этих файлов, могут быть удалены простым удалением их оттуда.
Только после каждого изменения нужно либо выйти и зайти в систему, либо выполнить эту команду:

`source имя_файла`

### Добавление пользовательских и системных переменных окружения в linux

**Локальные** переменные окружения в Linux можно создавать следующими командами:

`var=значение`

`export var=значение`

**Эти переменные будут доступны только для текущей терминальной сессии.**

#### Для удаления переменной для текущей сессии используется unset

`unset имя_переменной`

Для создания **пользовательских** переменных откройте файл `.bashrc` и измените его.

Например, через `nano`:

`nano ~/.bashrc`

И добавьте там, например, такую строчку:

`export CD='This is Losst Home'`

Чтобы изменения вступили в силу, нужно явно указать, что мы изменили этот файл, через команду `source`:

`source ~/.bashrc`

Для проверки можем вызвать команду `echo`, которая просто печатает переменные:

`echo $CD`

Для создания **системных** переменных нужно выполнить такие же действия как и с пользовательскими, но на системном 
уровне, для этого изменим файл `/etc/bash.profile`.

В остальном это будет работать точно так же.
