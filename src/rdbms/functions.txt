***********************
Functions and operators
***********************

Logical and comparison operators
================================

The usual logical operators are still available:

.. code-block:: sql

    boolean AND boolean -> boolean
    boolean OR boolean -> boolean
    NOT boolean -> boolean

SQL uses a three-valued logic system with ``true``, ``false``, and ``null``,
which represents *unknown*.

.. table:: Truth table

    +-----------+-----------+-------------+------------+-----------+
    | ``a``     | ``b``     | ``a AND b`` | ``a OR b`` | ``NOT a`` |
    +===========+===========+=============+============+===========+
    | ``TRUE``  | ``TRUE``  | ``TRUE``    | ``TRUE``   | ``FALSE`` |
    +-----------+-----------+-------------+------------+-----------+
    | ``TRUE``  | ``FALSE`` | ``FALSE``   | ``TRUE``   | ``FALSE`` |
    +-----------+-----------+-------------+------------+-----------+
    | ``TRUE``  | ``NULL``  | ``NULL``    | ``TRUE``   | ``FALSE`` |
    +-----------+-----------+-------------+------------+-----------+
    | ``FALSE`` | ``FALSE`` | ``FALSE``   | ``FALSE``  | ``TRUE``  |
    +-----------+-----------+-------------+------------+-----------+
    | ``FALSE`` | ``NULL``  | ``FALSE``   | ``NULL``   | ``TRUE``  |
    +-----------+-----------+-------------+------------+-----------+
    | ``NULL``  | ``NULL``  | ``NULL``    | ``NULL``   | ``NULL``  |
    +-----------+-----------+-------------+------------+-----------+

The operators ``AND`` and ``OR`` are commutative, that is, you can switch
the left and right operands without affecting the result. However, it is not
guaranteed that the left operand is evaluated before the right operand.

Comparison operators
--------------------

The usual comparison operators are available.

+-------------------------------------+--------------------------+
| Operator                            | Description              |
+=====================================+==========================+
| ``datatype < datatype -> boolean``  | Less than                |
+-------------------------------------+--------------------------+
| ``datatype > datatype -> boolean``  | Greater than             |
+-------------------------------------+--------------------------+
| ``datatype <= datatype -> boolean`` | Less than or equal to    |
+-------------------------------------+--------------------------+
| ``datatype >= datatype -> boolean`` | Greater than or equal to |
+-------------------------------------+--------------------------+
| ``datatype = datatype -> boolean``  | Equal                    |
+-------------------------------------+--------------------------+
| ``datatype <> datatype -> boolean`` | Not equal                |
+-------------------------------------+--------------------------+
| ``datatype != datatype -> boolean`` | Not equal                |
+-------------------------------------+--------------------------+

Mathematical functions and operators
====================================

Mathematical operators and provided for many PostgreSQL types.

+-----------------------------------------+-----------------------------------+
| Operation                               | Description                       |
+=========================================+===================================+
| ``numeric_type + numeric_type``         | Addition                          |
+-----------------------------------------+-----------------------------------+
| ``+ numeric_type``                      | Unary plus (no operation)         |
+-----------------------------------------+-----------------------------------+
| ``numeric_type - numeric_type``         | Subtraction                       |
+-----------------------------------------+-----------------------------------+
| ``- numeric_type``                      | Negation                          |
+-----------------------------------------+-----------------------------------+
| ``numeric_type * numeric_type``         | Multiplication                    |
+-----------------------------------------+-----------------------------------+
| ``numeric_type / numeric_type``         | Division (for integral types,     |
|                                         | division truncates the result     |
|                                         | towards zero)                     |
+-----------------------------------------+-----------------------------------+
| ``numeric_type % numeric_type``         | Modulo (remainder); available for |
|                                         | ``smallint``, ``integer``,        |
|                                         | ``bigint``, and ``numeric``       |
+-----------------------------------------+-----------------------------------+
| ``numeric ^ numeric``                   | Exponentiation                    |
| ``double precision ^ double precision`` |                                   |
+-----------------------------------------+-----------------------------------+
| ``|/ double precision``                 | Square root                       |
+-----------------------------------------+-----------------------------------+
| ``||/ double precision``                | Cube root                         |
+-----------------------------------------+-----------------------------------+
| ``@ numeric_type``                      | Absolute value                    |
+-----------------------------------------+-----------------------------------+
| ``integral_type & integral_type``       | Bitwise AND                       |
+-----------------------------------------+-----------------------------------+
| ``integral_type | integral_type``       | Bitwise OR                        |
+-----------------------------------------+-----------------------------------+
| ``integral_type # integral_type``       | Bitwise exclusive OR              |
+-----------------------------------------+-----------------------------------+
| ``~ integral_type``                     | Bitwise NOT                       |
+-----------------------------------------+-----------------------------------+
| ``integral_type << integer``            | Bitwise shift left                |
+-----------------------------------------+-----------------------------------+
| ``integral_type >> integer``            | Bitwise shift right               |
+-----------------------------------------+-----------------------------------+

String functions
================

*Strings* in this context include values of the types ``character``, ``text``
and ``character varying``.

.. todo: concat, pattern matching (like)

Date/Time functions and operators
=================================

.. todo: extract, date_part, date_trunc, current d/t, formatting d/t

Conditional expressions
=======================

.. todo: case, coalesce

Aggregate functions
===================

*Aggregate functions* compute a single result from a set of input values.
There are lots of these, and different RDBMS implement different aggregation
functions. In this section, we will focus on the most wide spread and often
used aggregate functions only.

The general schema of using is presented below:

.. image:: /../assets/img/aggregate-function.svg

Average value
-------------

.. function:: avg(smallint) -> numeric
              avg(integer) -> numeric
              avg(bigint) -> numeric
              avg(numeric) -> numeric
              avg(real) -> double precision
              avg(double precision) -> double precision
              avg(interval) -> interval

    Computes the average (arithmetic mean) of all the non-null input values

The ``avg`` function returns the average value of all non-null inputs within
a group.

.. important::

    SQLite implements ``avg`` function in a manner to return ``NULL`` if and
    only if all the inputs are nulls. On the other hand PostgreSQL will raise
    an error in this scenario.

.. code-block:: postgresql

    SELECT avg(amount),
           ceil(avg(amount)),
           extract(MONTH FROM date) AS month,
           extract(YEAR FROM date)  AS year
    FROM revenue
    GROUP BY month, year
    ORDER BY year, month
    LIMIT 5;

+-----------------------+-------+-------+------+
| avg                   | ceil  | month | year |
+=======================+=======+=======+======+
| 7797.6                | 7798  | 11    | 2013 |
+-----------------------+-------+-------+------+
| 6708.2857142857142857 | 6709  | 12    | 2013 |
+-----------------------+-------+-------+------+
| 6522.2                | 6523  | 1     | 2014 |
+-----------------------+-------+-------+------+
| 6831.5                | 6832  | 2     | 2014 |
+-----------------------+-------+-------+------+
| 10217.4               | 10218 | 3     | 2014 |
+-----------------------+-------+-------+------+

Count
-----

.. function:: count(*) -> bigint

    Computes the number of input rows

.. function:: count("any") -> bigint

    Computes the number of input rows in which the input value is not null

.. code-block:: postgresql

    SELECT *
    FROM revenue
    WHERE extract(month from date) = 1
    AND extract(year from date) = 2014;

+-----+-----------+------------+--------+
| id  | member_id | date       | amount |
+-----+-----------+------------+--------+
| 91  | 42        | 2014-01-18 | 6662   |
+-----+-----------+------------+--------+
| 196 | 214       | 2014-01-07 | 8853   |
+-----+-----------+------------+--------+
| 571 | 131       | 2014-01-13 | 8541   |
+-----+-----------+------------+--------+
| 671 | 64        | 2014-01-12 | 2636   |
+-----+-----------+------------+--------+
| 758 | 90        | 2014-01-18 | 5919   |
+-----+-----------+------------+--------+

.. code-block:: postgresql

    SELECT count(*)
    FROM revenue
    WHERE extract(month from date) = 1
    AND extract(year from date) = 2014;

+-------+
| count |
+=======+
| 5     |
+-------+
