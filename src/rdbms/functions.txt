***********************
Functions and operators
***********************

Logical operators and comparison
================================

The usual logical operators are still available:

.. code-block:: sql

    boolean AND boolean -> boolean
    boolean OR boolean -> boolean
    NOT boolean -> boolean

SQL uses a three-valued logic system with ``true``, ``false``, and ``null``,
which represents *unknown*.

.. table:: Truth table

    +-----------+-----------+-------------+------------+-----------+
    | ``a``     | ``b``     | ``a AND b`` | ``a OR b`` | ``NOT a`` |
    +===========+===========+=============+============+===========+
    | ``TRUE``  | ``TRUE``  | ``TRUE``    | ``TRUE``   | ``FALSE`` |
    +-----------+-----------+-------------+------------+-----------+
    | ``TRUE``  | ``FALSE`` | ``FALSE``   | ``TRUE``   | ``FALSE`` |
    +-----------+-----------+-------------+------------+-----------+
    | ``TRUE``  | ``NULL``  | ``NULL``    | ``TRUE``   | ``FALSE`` |
    +-----------+-----------+-------------+------------+-----------+
    | ``FALSE`` | ``FALSE`` | ``FALSE``   | ``FALSE``  | ``TRUE``  |
    +-----------+-----------+-------------+------------+-----------+
    | ``FALSE`` | ``NULL``  | ``FALSE``   | ``NULL``   | ``TRUE``  |
    +-----------+-----------+-------------+------------+-----------+
    | ``NULL``  | ``NULL``  | ``NULL``    | ``NULL``   | ``NULL``  |
    +-----------+-----------+-------------+------------+-----------+

The operators ``AND`` and ``OR`` are commutative, that is, you can switch
the left and right operands without affecting the result. However, it is not
guaranteed that the left operand is evaluated before the right operand.

Comparison operators
--------------------

The usual comparison operators are available.

+-------------------------------------+--------------------------+
| Operator                            | Description              |
+=====================================+==========================+
| datatype < datatype -> boolean      | Less than                |
+-------------------------------------+--------------------------+
| datatype > datatype -> boolean      | Greater than             |
+-------------------------------------+--------------------------+
| datatype <= datatype -> boolean     | Less than or equal to    |
+-------------------------------------+--------------------------+
| datatype >= datatype -> boolean     | Greater than or equal to |
+-------------------------------------+--------------------------+
| datatype = datatype -> boolean      | Equal                    |
+-------------------------------------+--------------------------+
| datatype <> datatype -> boolean     | Not equal                |
+-------------------------------------+--------------------------+
| datatype != datatype -> boolean     | Not equal                |
+-------------------------------------+--------------------------+

Comparison predicates
---------------------

::

    datatype BETWEEN datatype AND datatype -> boolean
        Between (inclusive of the range endpoints).
        2 BETWEEN 1 AND 3 -> t
        2 BETWEEN 3 AND 1 -> f

    datatype NOT BETWEEN datatype AND datatype -> boolean
        Not between (the negation of BETWEEN).
        2 NOT BETWEEN 1 AND 3 -> f

    datatype BETWEEN SYMMETRIC datatype AND datatype -> boolean
        Between, after sorting the two endpoint values.
        2 BETWEEN SYMMETRIC 3 AND 1 -> t

    datatype NOT BETWEEN SYMMETRIC datatype AND datatype -> boolean
        Not between, after sorting the two endpoint values.
        2 NOT BETWEEN SYMMETRIC 3 AND 1 -> f

    datatype IS DISTINCT FROM datatype -> boolean
        Not equal, treating null as a comparable value.
        1 IS DISTINCT FROM NULL -> t (rather than NULL)
        NULL IS DISTINCT FROM NULL -> f (rather than NULL)

    datatype IS NOT DISTINCT FROM datatype -> boolean
        Equal, treating null as a comparable value.
        1 IS NOT DISTINCT FROM NULL -> f (rather than NULL)
        NULL IS NOT DISTINCT FROM NULL -> t (rather than NULL)

    datatype IS NULL -> boolean
        Test whether value is null.
        1.5 IS NULL -> f

    datatype IS NOT NULL -> boolean
        Test whether value is not null.
        'null' IS NOT NULL -> t

    datatype ISNULL -> boolean
        Test whether value is null (nonstandard syntax).

    datatype NOTNULL -> boolean
        Test whether value is not null (nonstandard syntax).

    boolean IS TRUE -> boolean
        Test whether boolean expression yields true.
        true IS TRUE -> t
        NULL::boolean IS TRUE -> f (rather than NULL)

    boolean IS NOT TRUE -> boolean
        Test whether boolean expression yields false or unknown.
        true IS NOT TRUE -> f
        NULL::boolean IS NOT TRUE -> t (rather than NULL)

    boolean IS FALSE -> boolean
        Test whether boolean expression yields false.
        true IS FALSE -> f
        NULL::boolean IS FALSE -> f (rather than NULL)

    boolean IS NOT FALSE -> boolean
        Test whether boolean expression yields true or unknown.
        true IS NOT FALSE -> t
        NULL::boolean IS NOT FALSE -> t (rather than NULL)

    boolean IS UNKNOWN -> boolean
        Test whether boolean expression yields unknown.
        true IS UNKNOWN -> f
        NULL::boolean IS UNKNOWN -> t (rather than NULL)

    boolean IS NOT UNKNOWN -> boolean
        Test whether boolean expression yields true or false.
        true IS NOT UNKNOWN -> t
        NULL::boolean IS NOT UNKNOWN -> f (rather than NULL)

Comparison functions
--------------------

.. function:: num_nonnulls(VARIADIC "any")

    Returns the number of non-null arguments

.. code-block:: postgresql

    SELECT num_nonnulls(1, NULL, 2) -- return 2

.. function:: num_nulls(VARIADIC "any")

    Returns the number of null arguments

.. code-block:: postgresql

    SELECT num_nulls(1, NULL, 2) -- return 1
