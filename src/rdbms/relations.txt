.. meta::
    :description: This document describes the database relationships
    :author: Serhii Horodilov
    :keywords: sql, db, database, relationship, primary key, foreign key,
               pk, fk, one-to-one, one-to-many, many-to-many, 1-1, 1-n, n-m

*******************************************************************************
                              Data Relationships
*******************************************************************************

Before dive into relationships, there is a need explain core concepts on how
data are referenced between different tables.

Primary key
===========

A primary key constraint indicates that a column, or group of columns, can be
used as a unique identifier for rows in the table. This requires that values
be both unique and not null. So, the following two table definitions accept
the same data:

.. code-block:: postgresql

    CREATE TABLE publisher
    (
        id      INTEGER PRIMARY KEY,
        ...
    );

    CREATE TABLE publisher
    (
        id      INTEGER NOT NULL UNIQUE,
        ...
    );

Primary keys can span more than one column; the syntax is similar to unique
constraint:

.. code-block:: postgresql

    CREATE TABLE example
    (
        a INTEGER,
        b INTEGER,
        c INTEGER,
        PRIMARY KEY (a, c)
    );

Adding a primary key will automatically create a unique B-tree index on
the column or group of columns listed in the primary key, and will force
the column(s) to be marked ``NOT NULL``.

A table can have at most one primary key.

.. note::

    There can be any number of unique and not-null constraints, which are
    functionally almost the same thing, but only one can be identified as
    the primary key.

Foreign key (FK)
================

A foreign key constraint specifies that the value in a column (or a group of
columns) must match the values appearing in some row of another table. We say
this maintains the *referential integrity* between two tables.

A table can have more than one foreign key constraint. Foreign key can also
overlaps with the primary key.

To define a FK constraint:

.. code-block:: postgresql

    CREATE TABLE book
    (
        id           SERIAL PRIMARY KEY,
        publisher_id INTEGER REFERENCES publisher
    );

    CREATE TABLE book
    (
        id           SERIAL PRIMARY KEY,
        publisher_id INTEGER REFERENCES publisher (id)
    );

    CREATE TABLE book
    (
        id           SERIAL PRIMARY KEY,
        publisher_id INTEGER,
        FOREIGN KEY (publisher_id) REFERENCES publisher
    );

In this situation the ``book`` table is the *referencing* table, and
the ``publisher`` table is the *referenced* table. Similarly there are
referencing and referenced columns.

In case the referenced column is not explicitly defined, the primary key
of the referenced table will be used as the referenced column.

It is not possible to create a row with non-null foreign key, that does not
appear in the referenced table.

Self-referential foreign key
----------------------------

Sometimes it is useful to the referenced table to be the same table as
referencing. This makes possible to create a tree-structures with nodes,
there a top-level node would have ``NULL`` ``parent_id``.

.. code-block:: postgresql

    CREATE TABLE tree
    (
        id        SERIAL PRIMARY KEY,
        parent_id INTEGER REFERENCES tree
    );

Deleting referenced rows
------------------------

So far we know that the foreign keys disallows creation of rows that do not
relate to any row inside the referenced table. But what if a referenced row
needs to be removed? Intuitively, there are few options:

-   disallow deletion
-   delete referencing rows as well
-   something else...

Restricting and cascading deletes are the two most common options.
``RESTRICT`` prevents deletion of a referenced row. ``CASCADE`` will also
delete all referencing rows as well as the referenced one.

.. code-block:: postgresql

    CREATE TABLE book
    (
        id           SERIAL PRIMARY KEY,
        publisher_id INTEGER REFERENCES publisher ON DELETE RESTRICT
    );

    CREATE TABLE book
    (
        id           SERIAL PRIMARY KEY,
        publisher_id INTEGER REFERENCES publisher ON DELETE CASCADE
    );

There are others options.

``NO ACTION`` means that if any referencing rows still exist when
the constraint is checked, an error is raised; this is the default behavior.

``SET NULL`` will replace all referencing rows foreign key values with ``NULL``
values.

``SET DEFAULT`` will replace all referencing rows foreign key values with
default values.

Joining data
============

``JOIN`` is used to *join* data fetched from multiple related tables.
To build a valid query you are to set the tables to join and parameter to use
for this operation.

Common syntax is:

::

    T1 join_type T2 [ join_condition ]

There are various join types available.
Here are is some dummy data to demonstrate their purpose.

.. table:: poem

    +----+------------------------+-----------+
    | id | title                  | author_id |
    +====+========================+===========+
    |  1 | On the Field of Battle | 1         |
    +----+------------------------+-----------+
    |  2 | Moses                  | 2         |
    +----+------------------------+-----------+
    |  3 | The Forest Song        | 1         |
    +----+------------------------+-----------+
    |  4 | In the Catacombs       | null      |
    +----+------------------------+-----------+
    |  5 | The Singing Stones     | 1         |
    +----+------------------------+-----------+
    |  6 | Ancient Fairy Tales    | null      |
    +----+------------------------+-----------+
    |  7 | My Thoughts            | 2         |
    +----+------------------------+-----------+
    |  8 | To Shevchenko          | null      |
    +----+------------------------+-----------+


.. table:: author

    +----+---------------+
    | id | name          |
    +====+===============+
    | 1  | Larysa Kosach |
    +----+---------------+
    | 2  | Ivan Franko   |
    +----+---------------+
    | 3  | John Doe      |
    +----+---------------+

.. code-block:: sql

    CREATE TABLE author
    (
        id   SERIAL PRIMARY KEY,
        name VARCHAR(32) NOT NULL UNIQUE
    );
    CREATE TABLE poem
    (
        id        SERIAL PRIMARY KEY,
        title     VARCHAR(32) NOT NULL UNIQUE,
        author_id INT REFERENCES author (id)
    );
    INSERT INTO author(name)
    VALUES ('Larysa Kosach'),
           ('Ivan Franko'),
           ('John Doe');
    INSERT INTO poem(title, author_id)
    VALUES ('On the Field of Battle', 1),
           ('Moses', 2),
           ('The Forest Song', 1),
           ('In the Catacombs', null),
           ('The Singing Stones', 1),
           ('Ancient Fairy Tales', null),
           ('My Thoughts', 2),
           ('To Shevchenko', null)
    ;

Join types
----------

:Cross join:

    .. code-block::

        T1 CROSS JOIN T2

    For every possible combination of rows from T1 and T2
    (i.e., a Cartesian product), the joined table will contain a row consisting
    of all columns in T1 followed by all columns in T2. If the tables have N
    and M rows respectively, the joined table will have N * M rows.

:Qualified joins:

    .. code-block::

        T1 { [INNER] | { LEFT | RIGHT | FULL } [OUTER] } JOIN T2 ON condition

    The words ``INNER`` and ``OUTER`` are optional for all forms.
    ``INNER`` is the default; ``LEFT``, ``RIGHT`` and ``FULL`` imply ``OUTER``
    join.

INNER JOIN
----------

For each row R1 of T1, the joined table has a row for each row in T2 that
satisfies the join condition with R1.

.. code-block:: sql
    :caption: Inner join

    SELECT p.title, a.name
    FROM poem p
             JOIN author a on p.author_id = a.id;

+------------------------+---------------+
| title                  | name          |
+========================+===============+
| On the Field of Battle | Larysa Kosach |
+------------------------+---------------+
| Moses                  | Ivan Franko   |
+------------------------+---------------+
| The Forest Song        | Larysa Kosach |
+------------------------+---------------+
| The Singing Stones     | Larysa Kosach |
+------------------------+---------------+
| My Thoughts            | Ivan Franko   |
+------------------------+---------------+

LEFT OUTER JOIN
---------------

First, an inner join is performed. Then, for each row in T1 that does not
satisfy the join condition with any row in T2, a joined row is added with null
values in columns of T2. Thus, the joined table always has at least one row for
each row in T1.

.. code-block:: sql
    :caption: Left join

    SELECT p.title, a.name
    FROM poem p
             LEFT JOIN author a on p.author_id = a.id;

+------------------------+---------------+
| title                  | name          |
+========================+===============+
| On the Field of Battle | Larysa Kosach |
+------------------------+---------------+
| Moses                  | Ivan Franko   |
+------------------------+---------------+
| The Forest Song        | Larysa Kosach |
+------------------------+---------------+
| In the Catacombs       | null          |
+------------------------+---------------+
| The Singing Stones     | Larysa Kosach |
+------------------------+---------------+
| Ancient Fairy Tales    | null          |
+------------------------+---------------+
| My Thoughts            | Ivan Franko   |
+------------------------+---------------+
| To Shevchenko          | null          |
+------------------------+---------------+

RIGHT OUTER JOIN
----------------

First, an inner join is performed. Then, for each row in T2 that does not
satisfy the join condition with any row in T1, a joined row is added with
null values in columns of T1. This is the converse of a left join: the result
table will always have a row for each row in T2.

.. code-block:: sql
    :caption: Right join

    SELECT p.title, a.name
    FROM poem p
             RIGHT JOIN author a on p.author_id = a.id;

+------------------------+---------------+
| title                  | name          |
+========================+===============+
| On the Field of Battle | Larysa Kosach |
+------------------------+---------------+
| Moses                  | Ivan Franko   |
+------------------------+---------------+
| The Forest Song        | Larysa Kosach |
+------------------------+---------------+
| The Singing Stones     | Larysa Kosach |
+------------------------+---------------+
| My Thoughts            | Ivan Franko   |
+------------------------+---------------+
| null                   | John Doe      |
+------------------------+---------------+

FULL OUTER JOIN
---------------

First, an inner join is performed. Then, for each row in T1 that does not
satisfy the join condition with any row in T2, a joined row is added with
null values in columns of T2. Also, for each row of T2 that does not satisfy
the join condition with any row in T1, a joined row with null values in
the columns of T1 is added.

.. code-block:: sql
    :caption: Full join

    SELECT p.title, a.name
    FROM poem p
             FULL JOIN author a on p.author_id = a.id;

+------------------------+---------------+
| title                  | name          |
+========================+===============+
| On the Field of Battle | Larysa Kosach |
+------------------------+---------------+
| Moses                  | Ivan Franko   |
+------------------------+---------------+
| The Forest Song        | Larysa Kosach |
+------------------------+---------------+
| In the Catacombs       | null          |
+------------------------+---------------+
| The Singing Stones     | Larysa Kosach |
+------------------------+---------------+
| Ancient Fairy Tales    | null          |
+------------------------+---------------+
| My Thoughts            | Ivan Franko   |
+------------------------+---------------+
| To Shevchenko          | null          |
+------------------------+---------------+
| null                   | John Doe      |
+------------------------+---------------+
